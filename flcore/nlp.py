"""Utility functions for nlp work."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_nlp.ipynb.

# %% auto 0
__all__ = ['base_start', 'base_rest', 'name_part', 'particles', 're_person', 'TokenAnnotator', 'annotate']

# %% ../nbs/01_nlp.ipynb 3
import anywidget
import traitlets

# %% ../nbs/01_nlp.ipynb 4
class TokenAnnotator(anywidget.AnyWidget):
    _esm = """
    function render({ model, el }) {
    
        // Setup reactive state getters
        let getText = () => model.get('text');
        let getAnnotations = () => model.get('annotations');
        let getlabels = () => model.get('labels');
        
        // Create control panel
        const controls = document.createElement('div');
        controls.className = "annotation-labels"
        
        // Create radio buttons from labels
        getlabels().forEach(cls => {
            const label = document.createElement('label');
            const input = document.createElement('input');
            input.type = 'radio';
            input.name = 'class';
            input.value = cls;
            if (cls === getlabels()[0]) input.checked = true;
            label.appendChild(input);
            label.appendChild(document.createTextNode(' ' + cls));
            controls.appendChild(label);
            controls.appendChild(document.createTextNode(' '));
        });
        el.appendChild(controls);
        
        function preprocessText(text) {
            return text
                .replace(/^(# .+\\n?)/gm, '<h1>$1</h1>')
                .replace(/^(## .+\\n?)/gm, '<h2>$1</h2>')
                .replace(/^(### .+\\n?)/gm, '<h3>$1</h3>')
        }
        
        // Create content div
        const textDiv = document.createElement('div');
        
        //textDiv.textContent = getText();
        textDiv.innerHTML = preprocessText(getText());
        
        textDiv.className = "annotation-container";
        el.appendChild(textDiv);
        
        // Setup annotation tracking
        const originalText = getText();
        const colors = ['#ffd1dc', '#90EE90', '#87CEEB', '#FFB347', '#C8A2C8', '#FFE4B5'];
        let colorIndex = 0;
        const classColors = new Map();
        
        function getColorForClass(className) {
            if (!classColors.has(className)) {
                classColors.set(className, colors[colorIndex++ % colors.length]);
            }
            return classColors.get(className);
        }
        
        function getOriginalTextPosition(node, offset) {
            let currentPos = 0;
            const walker = document.createTreeWalker(textDiv, NodeFilter.SHOW_TEXT, null, false);
            
            let currentNode = walker.nextNode();
            while (currentNode) {
                if (currentNode === node) {
                    return currentPos + offset;
                }
                currentPos += currentNode.textContent.length;
                currentNode = walker.nextNode();
            }
            return offset;
        }
        
        function unwrapMark(mark) {
            const startPos = getOriginalTextPosition(mark.firstChild, 0);
            const annotations = getAnnotations().filter(a => a.start !== startPos);
            mark.replaceWith(...mark.childNodes);
            model.set('annotations', annotations);
            model.save_changes();
        }
        
        function findNodeAndOffsetAtPosition(container, targetPosition) {
            let currentPos = 0;
            const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, null, false);

            let lastNode = null;
            let node = walker.nextNode();

            while (node) {
                const nodeLength = node.textContent.length;
                if (currentPos + nodeLength >= targetPosition) {  // Changed > to >=
                    return {
                        node: node,
                        offset: targetPosition - currentPos
                    };
                }
                currentPos += nodeLength;
                lastNode = node;
                node = walker.nextNode();
            }

            // Handle the end-of-text case
            if (lastNode && targetPosition === currentPos) {
                return {
                    node: lastNode,
                    offset: lastNode.textContent.length
                };
            }

            return null;
        }
        // Then use it for initial annotations
        getAnnotations().forEach(annotation => {
            const startLoc = findNodeAndOffsetAtPosition(textDiv, annotation.start);
            const endLoc = findNodeAndOffsetAtPosition(textDiv, annotation.end);

            if (startLoc && endLoc) {
                const range = document.createRange();
                range.setStart(startLoc.node, startLoc.offset);
                range.setEnd(endLoc.node, endLoc.offset);

                const markElement = document.createElement('mark');
                markElement.style.backgroundColor = getColorForClass(annotation.class);
                markElement.title = `${annotation.class}`;

                markElement.addEventListener('click', e => {
                    e.preventDefault();
                    unwrapMark(markElement);
                });

                try {
                    range.surroundContents(markElement);
                } catch (e) {
                    console.error('Cannot wrap initial annotation that crosses multiple nodes', e);
                }
            }
        });
        
        textDiv.addEventListener('mouseup', () => {
            const selection = window.getSelection();
            
            if (selection.toString().trim().length > 0) {
                const range = selection.getRangeAt(0);
                const selectedClass = document.querySelector('input[name="class"]:checked').value;
                const markElement = document.createElement('mark');
                markElement.style.backgroundColor = getColorForClass(selectedClass);
                markElement.title = `${selectedClass}`;
                
                markElement.addEventListener('click', e => { 
                    e.preventDefault(); 
                    unwrapMark(markElement); 
                });
                
                try {
                    const startPos = getOriginalTextPosition(range.startContainer, range.startOffset);
                    const endPos = getOriginalTextPosition(range.endContainer, range.endOffset);
                    
                    const annotations = [...getAnnotations(), {
                        start: startPos,
                        end: endPos,
                        text: selection.toString(),
                        class: selectedClass
                    }];
                    
                    range.surroundContents(markElement);
                    selection.removeAllRanges();
                    
                    model.set('annotations', annotations);
                    model.save_changes();
                } catch (e) {
                    console.error('Cannot wrap selection that crosses multiple nodes', e);
                }
            }
        });
    }
    export default { render };
    """

    _css = """
    .annotation-container {
        padding: 20px;
        border: 1px solid #ccc;
        margin: 8px;
        white-space: pre-wrap;
        line-height: 1.6;

        /* Subtle lined paper effect using background-image */
        background-image: linear-gradient(transparent 1.5em, #f0f0f0 1.5em);
        background-size: 100% 1.6em;
        padding: 0.1em 1em;
    }
    
    .annotation-labels {
      display: flex;
      margin: 4px;
      gap: 1rem;
    }
    
    .annotation-labels label {
      display: flex;
      align-items: center;
      gap: 0.5rem; /* Space between radio button and label text */
      padding: 0.5rem 1rem;
      border: 1px solid #ccc;
      border-radius: 0.5rem;
      background: #f9f9f9;
      cursor: pointer;
    }
    
    mark {
        padding: 2px;
        border-radius: 2px;
        cursor: pointer;
    }
    
    mark:hover {
        filter: brightness(0.9);
    }
    
    /* Add to your _css string */
    h1, h2, h3 {
        /* Remove default heading margins since we're keeping newlines */
        margin: 0;
        font-weight: bold;
    }

    /* Different sizes for different heading levels */
    h1 { font-size: 1.8em; }
    h2 { font-size: 1.5em; }
    h3 { font-size: 1.3em; }
    """

    # Traitlets for syncing state
    text = traitlets.Unicode().tag(sync=True)
    annotations = traitlets.List([]).tag(sync=True)
    labels = traitlets.List([]).tag(sync=True)

# %% ../nbs/01_nlp.ipynb 13
import re
from typing import List, Dict, Any

# %% ../nbs/01_nlp.ipynb 14
def annotate(text: str, patterns: Dict[str, str]) -> Dict[str, Any]:
    """
    Annotate text with multiple patterns. If a pattern contains capture groups,
    uses the first capture group; otherwise uses the full match.
    
    Example:
        annotate("Hi there, John Doe!", {
            "greeting": r'Hi|Hello'
        })
    """
    annotations = []
    for cls, pattern in patterns.items():
        
        for m in re.finditer(pattern, text, re.UNICODE):
            start = m.start()
            end = m.end()
            
            """
            # If there's a capture group, use its positions
            if m.groups():
                start = m.start(1)  # position of first capture group
                end = m.end(1)
            else:
                start = m.start()   # position of full match
                end = m.end()
            """
            
            annotations.append({"class": cls, "start": start, "end": end})
    
    return {
        "text": text,
        "annotations": sorted(annotations, key=lambda x: x['start'])
    }

# %% ../nbs/01_nlp.ipynb 21
# First, let's handle names that can start with an apostrophe
base_start = r'[A-Z\u00C0-\u017F](?:\'[A-Z\u00C0-\u017F])?'  # Allows N' at start
base_rest = r'[a-z\u00C0-\u017F]+'

# Complete base name part with special characters
name_part = f'{base_start}{base_rest}(?:[-][A-Z\u00C0-\u017F][a-z\u00C0-\u017F]+)*'

# Particles (van, der, etc.)
particles = r'(?:\s+(?:van|der|de|den|von|und|le|la|di|el|al|bin|ibn|mac|mc|dos|das|do|da|of|af|av))*'

# Final pattern requiring at least two parts for a full name
re_person = fr'({name_part}(?:{particles}\s+{name_part})+)'
